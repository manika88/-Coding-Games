# -Coding-games
// The Descent
//Для решения задачи мне каждый раз нужно было находить самую высокую гору. Для нахождения самой высокой горы я создала 2 перменные: max и index. Вначале я прировняла переменную max к нулю так-как это самое маленькое значение которое возможно в данной задачи для высоты горы. Затем в цикле я сравнивала значение высоты новой горы и значение в переменной max, если значение высоты новой горы больше значения в max, то я обновляла значение в max  на высоту этой горы и добавляла её номер(индекс) в переменную index. Таким образом по окончанию цикла, когда я проверили все горы, в переменной index будет номер самой высокой горы, и я его вывожу.

//Temperatures
//Для решения задачи мне нужно найти самую близкую к нулю температуру из предложенных. Создаю переменную minraz, которую инициализирую числом, которое точно будет больше возможных температур. Затем сравниваю модуль нового числа t(новой температуры) с модулем minraz. Это нужно для того, чтобы подобрать близкое к нулю значение по модулю. Если значение модуля новой температуры t меньше значения модуля minraz, то изменяю значение в переменной minraz на новую температуру t. 
  Для проверки варианта, когда модуль minraz равен модулю t, также проверяю положительное ли t. Если t положительное, то в minraz должно находится отрицательное значение, равное значению в t по модулю. Из пары пары одинаковых по модулю отрицательного и положительного числа нам нужно выбрать пооложительное, поэтому в этом случае изменяею значение в переменной minraz на значение в переменной t.
  Для проверки условия, когда температура не указана до цикла создаем векторный массив Mass, в который в цикле добавляем значения температуры. После цикла проверяем пустой ли массив. Если он пустой значит нам не дана температура и по условиям задачи, приравниваю minraz к нулю.
  После цикла и проверки массива выводим  minraz-ближайшую к нулю температуру из заданных.

  В этой задаче у меня была трудность с проверкой условия, когда температура не дана. В начале я хотела каждый раз в цикле проверять переменную t, но затем я поняла, что нужно использовать массив.

//Horse-racing Duals
// Для решения задачи мне нужно вывести разницу между двумя наиболее бликими силами. Для упрощенного решения этой задачи или когда подается много значений силы, я создаю векторный массив s, в который  в цикле добавляю значения силы лошадей. После добавления всех значений в массив сортирую его, что бы значения в нём шли по возрастанию. Таким образом уменьшаем колличество вычислений, ведь мы вычисляем и проверяем разницу только между соседними числами.
  Создаем переменную mindiff и нициализируем её значением, которое точно больше любой разницы между двумя силами в этой задаче. В цикле вычисляем разницу между двумя соседними значениями массива и записываем её в переменную diff. Если  diff меньше mindiff, то обновляем значение в mindiff на значение diff. Таким образом по окончанию цикла мы находим минимальную разность между двумя силами и выводим её.

  //Power of Thor - Episode 1
  //Для решения этой задачи нам нужно вывести направление движения Тора. Для того что бы правильно вывести направление движения нам нужно отслеживать текущее положение Тора, которое меняется после каждого хода. Содадим переменные для отслеживания текущего положения по горизонтали и по вертикали current_tx и current_ty, в начале прирравняем их к стартовым координатам current_tx = initial_tx и current_ty = initial_ty. Затем в цикле вычисляем разницу между положением света силы и положением Тора по вертикали и по горизонтали для определения, куда нужно двигаться и записываем их в переменные y и x. Создаем строку direction, в которую мы после каждого хода будем записывать направление(север, юг, восток или запад) куда нужно двигаться. В цикле проверяем если разница между положение света силы и положением Тора по вертикали(y) > 0, значит сила света находится ниже Тора и надо двигаться на юг: в строку direction добовляем направление S и увеличиваем значение текущего положения Тора по вертикали. Иначе сила света находится выше Тора и нужно двигаться на север: в строку direction добовляем направление N  и уменьшаем значение текущего положения Тора по вертикали.
  Аналогично вычисляем движение тора по горизонтали. Если x > 0- сила света находится правее Тора и нужно двигаться на восток : в строку direction добовляем направление E и увеличиваем значение текущего положения Тора по горизонтали. Иначе сила света находится левее Тора и нужно двигаться на запад : в строку direction добовляем направление W и уменьшаем значение текущего положения Тора по горизонтали.
  После окончания цикла выводим direction-которая будет показывать как нужно двигаться Тору, что бы достичь силы света.

//Mars Lander - Episode 1
// Для решения задачи я проверяла скорость по вертикали и если она была <=-40, согласно условию выводила угол поворота равный 0 и силу тяги равную 4.Иначе выводила угол поворота и силу тяги равные 0.
